@{
}
<script>

    function storageAvailable(type) {
        try {
            var storage = window[type],
                x = '__storage_test__';
            storage.setItem(x, x);
            storage.removeItem(x);
            return true;
        }
        catch(e) {
            return e instanceof DOMException && (
                // everything except Firefox
                e.code === 22 ||
                // Firefox
                e.code === 1014 ||
                // test name field too, because code might not be present
                // everything except Firefox
                e.name === 'QuotaExceededError' ||
                // Firefox
                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
                // acknowledge QuotaExceededError only if there's something already stored
                storage.length !== 0;
        }
    }

    var localStorage = undefined;
    if (storageAvailable('localStorage')) {
        localStorage = window['localStorage'];
    }
    else {
        // Too bad, no localStorage for us
    }

    function NoteModel(data)
    {
        var self = this;
        self.id = data.id;
        self.text = ko.observable(data.text);
        self.ConvertToJs = function() {
            return {
                id: self.id,
                text: self.text()
            };
        };
        self.text
            .subscribe(function() {
                var temp = self.ConvertToJs();
                if(self.textChangesOccuredHandler && typeof(self.textChangesOccuredHandler) == "function") {
                    self.textChangesOccuredHandler(temp);
                }
            });

        self.textChangesOccuredHandler;
        self.subscribeToTextChanges = function(callback) {
            self.textChangesOccuredHandler = callback;
        };
    };

    function ConnectedNotesModel(id, sourceId, destinationId, label)
    {

        var self = this;
        self.changes = ko.observableArray([]);
        self.id = id;
        self.SourceId = sourceId;
        self.DestinationId = destinationId;
        self.label = ko.observable(label);
        self.labelUpdateCallback;
        self.ConvertToJs = function() {
            return {
                id: self.id,
                SourceId: self.SourceId,
                DestinationId:  self.DestinationId,
                label: self.label()
            };
        };
        self.label
            .subscribe(function() {
                var temp = self.ConvertToJs();
                if(self.labelUpdateCallback && typeof(self.labelUpdateCallback) == "function") {
                    self.labelUpdateCallback(temp);
                }
            });
        self.subscribeToLabelChanges = function(callback) {
            self.labelUpdateCallback = callback;
        };


    };

    var storageForCallBacks = {
        note: {
            added: '',
            updated: '',
            removed: ''
        },
        connection: {
            added: '',
            updated: '',
            removed: ''
        }
    };

    function ConnectedNotesViewModel()
    {
        var self = this;

        
        self.freeLocalIndex = 0;
        self.localPrefix = 'local_' + new Date().toUTCString().split(' ').join('_');
        self.Notes = ko.observableArray([]);
        self.Connections = ko.observableArray([]);

        self.changes = ko.observableArray([]);

        self.populate = function(data) {
            var toAdd = ko.utils.arrayMap(data.notes, function(elem) {
                    var noteToAdd = new NoteModel(elem);
                    noteToAdd.subscribeToTextChanges(function(updated) {
                        self.changes.push({
                            action: 'NoteUpdated',
                            data: updated
                        }
                        );
                        storageForCallBacks.note.updated(updated);
                    }  );
                return noteToAdd;
            });
            ko.utils.arrayPushAll(self.Notes, toAdd);

            var connectionsToAdd = ko.utils.arrayMap(data.connections, function(elem) {
                var connectionToAdd = new ConnectedNotesModel(elem.id, elem.SourceId, elem.DestinationId, elem.label);
                connectionToAdd.subscribeToLabelChanges(function(updated) {
                    self.changes.push({
                        action: 'ConnectionUpdated',
                        data: updated
                    });
                    storageForCallBacks.connection.updated(updated);
                });
                return connectionToAdd;
            });
            ko.utils.arrayPushAll(self.Connections, connectionsToAdd);
        };



        self
            .changes
            .extend(
                { 
                    rateLimit: 1000 
                }
            )
            .subscribe(
                function(changes) {
                    if(changes && changes.length > 0)
                    {
                        if(changes[0].status == "added")
                        {
                            if(localStorage)
                            {
                                var toStoreNotes = ko.utils.arrayMap(self.Notes(), function(item) {
                                    return item.ConvertToJs();
                                });
                                var toStoreConnections = ko.utils.arrayMap(self.Connections(), function(item) {
                                    return item.ConvertToJs();
                                });
                                localStorage.setItem("Notes", JSON.stringify(toStoreNotes));
                                localStorage.setItem("Connections", JSON.stringify(toStoreConnections));
                            }
                            self.changes.removeAll();

                        }
                        // $.each(changes, function(index, value) {
                        //     if(value.status == "added") {
                        //     }
                        // });
                        // if(localStorage)
                        // {
                        //     //localStorage.

                        // }
                    }
                }
                ,null
                ,"arrayChange"
            );


        self.getLocalIndex = function() {
            return ( self.localPrefix + (self.freeLocalIndex++) );
        };

        self.SearchNotesQuery = ko.observable("");
        self.SearchFilter = function(item, searchTerm) {
            searchTerm = searchTerm.trim().toLowerCase();
            var searchString = item.text.toLowerCase();
            return searchString.indexOf(searchTerm) > -1;
        };

        self.SearchDestinationNotesQuery = ko.observable("");

        self.SearchableNotes = ko.computed(function() {
            return ko.utils.arrayMap(self.Notes(), function(item) {
                return {text: item.text(), id: item.id};
            });
        });

        self.Notes.subscribe(function(changes) {
            if(changes && changes.length > 0)
            {
                $.each(changes, function(index, value) {
                    if(value.status == "added") {
                        if(typeof(storageForCallBacks.note.added) == "function") {
                            var added = value.value.ConvertToJs();
                            self.changes.push({
                                action: 'NoteAdded',
                                data: added
                            });
                            storageForCallBacks.note.added(added);
                        }
                    }
                    if(value.status == "deleted") {
                        if(typeof(storageForCallBacks.note.removed) == "function") {
                            var deleted = value.value.ConvertToJs();
                            self.changes.push({
                                action: 'NoteDeleted',
                                data: deleted
                            });
                            storageForCallBacks.note.removed(deleted);
                        }
                    }
                });
            }
        }, null, "arrayChange");

        self.Connections.subscribe(function(changes) {
            if(changes && changes.length > 0)
            {
                $.each(changes, function(index, value) {
                    if(value.status == "added") {
                        if(typeof(storageForCallBacks.connection.added) == "function") {
                            var added = value.value.ConvertToJs();
                            self.changes.push({
                                action: 'ConnectionAdded',
                                data: added
                            });
                            storageForCallBacks.connection.added(added);
                        }
                    }
                    if(value.status == "deleted") {
                        if(typeof(storageForCallBacks.connection.removed) == "function") {
                            var deleted = value.value.ConvertToJs();
                            self.changes.push({
                                action: 'ConnectionDeleted',
                                data: deleted
                            });
                            storageForCallBacks.connection.removed(deleted);
                        }
                    }
                });
            }
        }, null, "arrayChange");
        

        self.RetrieveDataFromServer = function() {
            $.ajax({
                type: "POST",
                url: "Home/RetrieveAllNotes",
                data: {
                },
                success: self.populate,
                dataType: "json"
            });

        };

        if(localStorage)
        {
            if(localStorage["Notes"]){
                var data = {};
                data.notes = JSON.parse(localStorage.getItem("Notes"));
                data.connections = JSON.parse(localStorage.getItem("Connections"));
                self.populate(data);
            }
            
        }

        self.connectFrom = ko.observable(null);
        self.previousConnectFrom = ko.observable(null);

        self.CreateNote = function(text, callback) {

            
            var toAdd = new NoteModel(
                {
                    id: self.getLocalIndex(),
                    text: text
                });
            toAdd.subscribeToTextChanges(
                function(updated) {
                    self.changes.push({
                            action: 'NoteUpdated',
                            data: updated
                        }
                    ); 
                    storageForCallBacks.note.updated(updated);
                }
            );
            self.Notes.push(toAdd);
            if(callback && typeof(callback) === "function") {
                callback(toAdd);
            }
        };

        self.CreateNoteFromSearchQuery = function() {
            self.CreateNote(self.SearchNotesQuery().trim());
        };

        self.CreateNoteFromDestinationSearchQuery = function() {
            self.CreateNote(self.SearchDestinationNotesQuery().trim(), function(destination) { self.ConnectNotes(self.connectFrom(), destination); });
        };

        self.SelectFrom = function(data) {
            self.previousConnectFrom(self.connectFrom());
            self.connectFrom(data);

        };

        self.ConnectPreviousWithCurrent = function() {
            self.ConnectNotes(self.previousConnectFrom(), self.connectFrom() )
        };
        self.ConnectCurrentWithPrevious = function() {
            self.ConnectNotes(self.connectFrom(), self.previousConnectFrom() )
        };

        self.ConnectNotes = function(from, to) {
            var connectionToAdd = new ConnectedNotesModel(
                self.getLocalIndex(),
                from.id,
                to.id,
                ""
            );
            connectionToAdd.subscribeToLabelChanges(function(updated) {
                self.changes.push({
                    action: 'ConnectionUpdated',
                    data: updated
                });
                storageForCallBacks.connection.updated(updated);
            });
            self.Connections.push(connectionToAdd);
        };

        self.RemoveNote = function( note) {
            self.Notes.remove(note);
        };

        self.RemoveConnection = function(connection) {
            self.Connections.remove(connection);
        };

        self.NoteToEdit = ko.observable(null);

        self.SelectNoteToEdit = function(id) {
            var filtered = ko.utils.arrayFilter(self.Notes(), function(item){ return item.id == id;} );
            var from = filtered.length > 0 ? filtered[0] : null;
            
            self.NoteToEdit( from );
            self.SelectFrom( from )
        };

        self.DeselectNoteToEdit = function() {
            self.NoteToEdit(null);
        };

        

    };

    $(document).ready(function()
    {
        
        // create an array with nodes
        var nodes = new vis.DataSet([
        ]);

        // create an array with edges
        var edges = new vis.DataSet([
        ]);

        // create a network
        var container = document.getElementById('mygraph');
        var data = {
            nodes: nodes,
            edges: edges
        };
        var options = {};
        var network = new vis.Network(container, data, options);

        
        network.on("selectEdge", function (params) {
            console.log('selectEdge Event:', params);
        });
        
        network.on("deselectEdge", function (params) {
            console.log('deselectEdge Event:', params);
        });

        storageForCallBacks.note.added = function (added) {
            nodes.add( {id: added.id, label: added.text, shape: 'box' });
        };

        storageForCallBacks.note.updated = function(changed) {
            nodes.update({id: changed.id, label: changed.text}); 
        };

        storageForCallBacks.note.removed = function(node) {
            nodes.remove(node.id);
        };

        storageForCallBacks.connection.added = function(connectionAdded) {
            edges.add( {
                id: connectionAdded.id,
                from: connectionAdded.SourceId,
                to: connectionAdded.DestinationId,
                arrows: 'to',
                label: connectionAdded.label,
                font: { align: 'top' } 
            });
        };

        storageForCallBacks.connection.updated = function(connectionUpdated) {
            edges.update({
                id: connectionUpdated.id,
                label: connectionUpdated.label
            });
        };

        storageForCallBacks.connection.removed = function(connection) {
            edges.remove(connection.id);
        };
        
        var viewModel = new ConnectedNotesViewModel();
        ko.applyBindings(viewModel);
        viewModel.RetrieveDataFromServer();


        

        network.on("selectNode", function (params) {
            //console.log('selectNode Event:', params);
            viewModel.SelectNoteToEdit(params.nodes[0]);
        });

        network.on("dragStart", function (params) {
            viewModel.SelectNoteToEdit(params.nodes[0]);
        });

        network.on("deselectNode", function (params) {
            //console.log('deselectNode Event:', params);
            viewModel.DeselectNoteToEdit();
        });
        


        
    });
</script>
<div style="position: absolute; top:0px; left: 0px; z-index: 10; width: 100vw;">
    <div style="text-align: center; width: 100%; margin-top: 10px;">
        WebPad 
        <span data-bind="ifnot: $root.NoteToEdit() != null && $root.NoteToEdit() !=  undefined " >
            <input 
                placeholder="Create or search note..." 
                style="width: 30vw; min-width: 150px;" 
                type="text" 
                data-bind="
                    textInput: $root.SearchNotesQuery,
                    " />
            <span data-bind="if: $root.SearchNotesQuery().trim().length > 0">
                <button data-bind="click: $root.CreateNoteFromSearchQuery">Create</button>
            </span>  
        </span>
        
        <span data-bind="if: $root.NoteToEdit() != null && $root.NoteToEdit() !=  undefined " >
            <input 
                placeholder="Edit note..." 
                style="width: 30vw; min-width: 150px;" 
                type="text" 
                data-bind="
                    textInput: $root.NoteToEdit().text,
                    " />
            <span data-bind="if: $root.previousConnectFrom() != null && $root.previousConnectFrom() !=  undefined " >
                <span data-bind="if: $root.previousConnectFrom() == $root.NoteToEdit()" >
                    <br>
                    <button data-bind="click: $root.ConnectPreviousWithCurrent, text: ('Loop this ' + $root.previousConnectFrom().text())"></button>
                </span>
                <span data-bind="ifnot: $root.previousConnectFrom() == $root.NoteToEdit()" >
                    <br>
                    <button data-bind="click: $root.ConnectPreviousWithCurrent, text: ('Connect ' + $root.previousConnectFrom().text() + ' => ' + $root.NoteToEdit().text())"></button>
                    <br>
                    <button data-bind="click: $root.ConnectCurrentWithPrevious, text: ('Connect ' + $root.NoteToEdit().text() + ' => ' + $root.previousConnectFrom().text())"></button>
                </span>
                
            </span>
            
            <br>
            Connects to:
            <input 
                placeholder="Create or search note..." 
                style="width: 30vw; min-width: 150px;" 
                type="text" 
                data-bind="
                    textInput: $root.SearchDestinationNotesQuery,
                    " />
            <span data-bind="if: $root.SearchDestinationNotesQuery().trim().length > 0">
                <button data-bind="click: $root.CreateNoteFromDestinationSearchQuery">Create connection</button>
            </span> 
        </span>                  
        
    </div>
    
</div>
<div id="mygraph" style="height: 100vh; width: 100%; z-index: 9;">
</div>
